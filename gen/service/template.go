package service

var serviceCommon = `// Code generated by gen_batch.go; DO NOT EDIT.
// GENERATED FILE DO NOT EDIT

package {{ .Package }}

import (
	"fmt"
	"reflect"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
)

func buildParam(req interface{}, out interface{}, fields []string) (map[string]interface{}, error) {
	mapping := make(map[string]interface{})
	rVal := reflect.ValueOf(req)
	rType := reflect.TypeOf(req)
	if rType.Kind() == reflect.Ptr {
		rVal = rVal.Elem()
		rType = rType.Elem()
	}

	oVal := reflect.ValueOf(out)
	oType := reflect.TypeOf(out)
	if oType.Kind() == reflect.Ptr {
		oVal = oVal.Elem()
		oType = oType.Elem()
	}

	for i := 0; i < len(fields); i++ {
		fieldName := fields[i]
		name := strcase.ToCamel(fields[i])
		rActualVal := rVal.FieldByName(name)
		oActualVal := oVal.FieldByName(name)

		// compare value and set
		switch rActualVal.Kind() {
		case reflect.String:
			src := rActualVal.String()
			target := oActualVal.String()
			if src != target {
				oActualVal.SetString(src)
				mapping[fieldName] = src
			}
		case reflect.Int, reflect.Int32, reflect.Int64, reflect.Int8, reflect.Int16:
			src := rActualVal.Int()
			target := oActualVal.Int()
			if src != target {
				oActualVal.SetInt(src)
				mapping[fieldName] = src
			}
		case reflect.Float32, reflect.Float64:
			src := rActualVal.Float()
			target := oActualVal.Float()
			if src != target {
				oActualVal.SetFloat(src)
				mapping[fieldName] = src
			}
		case reflect.Bool:
			src := rActualVal.Bool()
			target := oActualVal.Bool()
			if src != target {
				oActualVal.SetBool(src)
				mapping[fieldName] = src
			}
		default:
			fmt.Printf("unknow type")
		}
	}

	return mapping, nil
}

// checkAppName - check app name format
func checkAppName(value string) error {
	if strings.Contains(value, " ") {
		return fmt.Errorf("invalid param, param can not contain space")
	}

	if len(value) > 32 {
		return fmt.Errorf("invalid param length")
	}

	// 中文、数字、字母、下划线
	pattern := "^[\u4E00-\u9FA5A-Za-z0-9_]+$"
	reg, err := regexp.Compile(pattern)
	if err != nil {
		return err
	}

	if !reg.MatchString(value) {
		return fmt.Errorf("invalid param")
	}

	return nil
}

// checkAppAlias - check app alias format
func checkAppAlias(value string) error {
	if strings.Contains(value, " ") {
		return fmt.Errorf("invalid param, param can not contain space")
	}

	if len(value) > 16 {
		return fmt.Errorf("invalid param length")
	}

	// 数字、小写字母、中线
	pattern := "^[a-z0-9-]+$"
	reg, err := regexp.Compile(pattern)
	if err != nil {
		return err
	}

	if !reg.MatchString(value) {
		return fmt.Errorf("invalid param")
	}

	return nil
}

// checkAppKeyspace - check app keyspace format
func checkAppKeyspace(value string) error {
	if strings.Contains(value, " ") {
		return fmt.Errorf("invalid param, param can not contain space")
	}

	if len(value) > 16 {
		return fmt.Errorf("invalid param length")
	}

	// 数字、小写字母、下划线
	pattern := "^[a-z0-9_]+$"
	reg, err := regexp.Compile(pattern)
	if err != nil {
		return err
	}

	if !reg.MatchString(value) {
		return fmt.Errorf("invalid param")
	}

	return nil
}

// CheckEmail check Email string
func CheckEmail(email string) error {
	//匹配电子邮箱
	pattern := ` + "`\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*`" + `
	reg := regexp.MustCompile(pattern)
	if !reg.MatchString(email) {
		return fmt.Errorf("invalid email formats")
	}
	return nil
}

`

var serviceTemplate = `// Code generated by gen_batch.go; DO NOT EDIT.
// GENERATED FILE DO NOT EDIT

package {{ .Package }}

import (
	"context"
	"fmt"
	{{ range $index, $path := .ImportPaths -}}
	"{{- $path -}}"
	{{ end }}
)

const(
	{{ .DstName }}Success 			= 0
	{{ .DstName }}Failure 			= 1
	{{ .DstName }}InvalidParams	= 2
	ErrorCreate{{ .DstName }} 		= {{ .Index }}1
	ErrorQuery{{ .DstName }} 		= {{ .Index }}2
	ErrorUpdate{{ .DstName }} 		= {{ .Index }}3
	ErrorDelete{{ .DstName }} 		= {{ .Index }}4
	ErrorList{{ .DstName }} 		= {{ .Index }}5
)

// Add{{ .DstName }} - create a new {{ .DstName | ToSnake }}
func Add{{ .DstName}}(ctx context.Context, req *proto.{{ .ReqName }}) (int64, string, int64) {
	{{ if eq .CheckApp true }} 
	// check whether app is exist
	if _, err := models.GetApp(req.AppId); err != nil {
		return {{ .DstName }}InvalidParams, fmt.Sprintf("query by appID err, err:%v", err.Error()), 0
	}
	{{ end }}

	{{ .DstConstruct }}
	id, err := models.Add{{ .DstName }}(val)
	if err != nil {
		return ErrorCreate{{ .DstName }}, err.Error(), 0
	}
	return {{ .DstName }}Success, fmt.Sprintf("create {{ .DstName | ToSnake }} success, id:%v", id), id
}

// Get{{ .DstName }} - query {{ .DstName | ToSnake }}
func Get{{ .DstName }}(ctx context.Context, id int64) (int64, string, *proto.{{ .ReqName }}) {
	val, err := models.Get{{ .DstName }}(id)
	if err != nil {
		return ErrorQuery{{ .DstName }}, err.Error(), nil
	}
	return {{ .DstName }}Success, "query {{ .DstName | ToSnake }} success", convert{{ .DstName }}(val)
}

// Get{{ .DstName }}ByKey - query {{ .DstName | ToSnake }} by key and value
func Get{{ .DstName }}ByKey(ctx context.Context, key string, value interface{}) (int64, string, *proto.{{ .ReqName }}) {
	val, err := models.Get{{ .DstName }}ByKey(key, value)
	if err != nil {
		return ErrorQuery{{ .DstName }}, err.Error(), nil
	}
	return {{ .DstName }}Success, "query {{ .DstName | ToSnake }} by key success", convert{{ .DstName }}(val)
}

// Update{{ .DstName }} - update {{ .DstName | ToSnake }}
func Update{{ .DstName }}(ctx context.Context, req *proto.{{ .ReqName }}, fields []string) (int64, string, interface{}) {
	id := req.Id
	val, err := models.Get{{ .DstName }}(id)
	if err != nil {
		return ErrorQuery{{ .DstName }}, err.Error(), nil
	}

	params, err := buildParam(req, val, fields)
	if err != nil {
		return {{ .DstName }}InvalidParams, err.Error(), nil
	}

	rowAffected, err := models.Edit{{ .DstName }}(val, params)
	if err != nil {
		return ErrorUpdate{{ .DstName }}, err.Error(), nil
	}
	return {{ .DstName }}Success, fmt.Sprintf("update {{ .DstName | ToSnake }} success, affected count:%v", rowAffected), nil
}

// Delete{{ .DstName }} - delete {{ .DstName | ToSnake }}
func Delete{{ .DstName }}(ctx context.Context, id int64) (int64, string, interface{}) {
	rowAffected, err := models.Delete{{ .DstName }}(id)
	if err != nil {
		return ErrorDelete{{ .DstName }}, err.Error(), nil
	}
	return {{ .DstName }}Success, fmt.Sprintf("delete {{ .DstName | ToSnake }} success, affected count:%v", rowAffected), nil
}

// Delete{{ .DstName }}ByKey - delete {{ .DstName | ToSnake }} by key
func Delete{{ .DstName }}ByKey(ctx context.Context, key string, value interface{}) (int64, string, interface{}) {
	rowAffected, err := models.Delete{{ .DstName }}ByKey(key, value)
	if err != nil {
		return ErrorDelete{{ .DstName }}, err.Error(), nil
	}
	return {{ .DstName }}Success, fmt.Sprintf("delete {{ .DstName | ToSnake }} by key success, affected count:%v", rowAffected), nil
}

// List{{ .DstName }} - query {{ .DstName | ToSnake }} list
func List{{ .DstName }}(ctx context.Context, param *proto.Filter) (int64, string, *proto.List) {
	list, err := models.List{{ .DstName }}(int64(param.Offset), int64(param.Limit), param.Order, param.Params())
	if err != nil {
		return ErrorList{{ .DstName }}, err.Error(), nil
	}

	resp := make([]*proto.{{ .ReqName }}, 0)
	for i := 0; i < len(list); i++ {
		resp = append(resp, convert{{ .DstName }}(&list[i]))
	}

	total, err := models.Count{{ .DstName }}(param.Params())
	if err != nil {
		return ErrorList{{ .DstName }}, err.Error(), nil
	}
	return {{ .DstName }}Success, "list {{ .DstName | ToSnake }} success", &proto.List{Total: total, Data: resp}
}

func convert{{ .DstName }}(req *models.{{ .DstName }}) *proto.{{ .ReqName }} {
	if req == nil {
		return nil
	}

	{{ .ConvertConstruct }}
	return val
}

`
